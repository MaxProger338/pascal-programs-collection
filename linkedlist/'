unit linkedlist;
interface

type
	Nodeptr = ^Node;
	Node = record
		next: Nodeptr;
		data: integer;
	end;

procedure CreateList(var myNode: Nodeptr; data: integer);
procedure DeleteList(myNode: Nodeptr);
function  GetSize(myNode: Nodeptr): word;
procedure AddNode(var myNode: Nodeptr; data: integer);
procedure RemoveNode(myNode: Nodeptr);
function  GetNode(myNode: Nodeptr; index: word): integer;
procedure SetNode(myNode: Nodeptr; index: word; data: integer);

implementation

{ private }
procedure CreateList(var myNode: Nodeptr; data: integer);
begin
	writeln('Creating list');
	new(myNode);
	myNode^.next := nil;
	myNode^.data := data;
end;

procedure DeleteList(myNode: Nodeptr);
var
	next: Nodeptr;
begin
	writeln('Deleting node ', PtrUInt(@myNode^));
	if myNode = nil then
		exit;

	next := myNode^.next;
	dispose(myNode);

	if next = nil then
		exit;

	DeleteList(next);
end;

function GetSize(myNode: Nodeptr): word;
begin
	if myNode^.next = nil then
	begin
		GetSize := 1;
		exit;
	end;

	GetSize := GetSize(myNode^.next) + 1;
end;

procedure AddNode(var myNode: Nodeptr; data: integer);
begin
	writeln('Adding new node', ' data=', data);

	if myNode = nil then
	begin
		writeln('List is empty');
		CreateList(myNode, data);
		writeln('List was created', ' data=', myNode^.data);
		exit;
	end;

	writeln('Adding new node 2, ', 'data=', data);
	AddNode(myNode^.next, data);
end;

procedure RemoveNode(myNode: Nodeptr);
begin
	if myNode^.next = nil then
		DeleteList(myNode);

	if myNode^.next^.next = nil then
	begin
		DeleteList(myNode^.next);
		myNode^.next := nil;
	end;
		
	RemoveNode(myNode^.next);
end;

function GetNode(myNode: Nodeptr; index: word): integer;
var
	size: word;
begin
	size := GetSize(myNode);
	if index >= size then
		halt(1001);

	if index = 0 then
	begin
		GetNode := myNode^.data;
		exit;
	end;

	GetNode := GetNode(myNode^.next, index - 1);
end;

procedure SetNode(myNode: Nodeptr; index: word; data: integer);
var
	size: word;
begin
	size := GetSize(myNode);
	if index >= size then
		halt(1001);

	if index = 0 then
	begin
		myNode^.data := data;
		exit;
	end;

	SetNode(myNode^.next, index - 1, data);
end;

end.
